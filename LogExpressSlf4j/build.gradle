buildscript {

    dependencies {
        classpath 'org.bouncycastle:bcpg-jdk15on:1.70'
        classpath 'org.bouncycastle:bcpg-jdk15on:1.70'
        def path = file("${projectDir}/../libs-build").getCanonicalFile().getAbsolutePath();

        classpath fileTree(dir:path, include: ['*.jar'])
    }
}
import com.hancomins.util.JarSign
import com.hancomins.util.PomBuilder


plugins {
    id 'java'
    id 'distribution'
}



group 'com.hancomins'
version getProperty("version")



def JAVA_VERSION = 1.6
sourceCompatibility = JAVA_VERSION
compileJava {
    sourceCompatibility=JAVA_VERSION
    targetCompatibility=JAVA_VERSION
    options.encoding = 'UTF-8'
}




compileTestJava {
    sourceCompatibility=JAVA_VERSION
    targetCompatibility=JAVA_VERSION
    options.encoding = 'UTF-8'
}



project.jar.exclude('**/*.txt')
project.jar.exclude('**/*.log')
project.jar.exclude('**/*.ini')

sourceSets {
    // JAVA 소스 파일 경로,
    // *Test.java 이름을 갖고 있는 파일은 포함하지 않는다.
    main.java.srcDirs = ['src/main/java']
    main.java.exclude '**/*Test.java'

    // 테스트 JAVA 소스 파일 경로, 자바 파일만 포함.
    test.java.srcDirs = ["src/test/java"]
    test.java.include "**/*Test.java"

}


compileJava.options.encoding = 'UTF-8'
String signPropsFilePath =  getAbsolutePath("${projectDir}/../sign.properties");
Properties signProperties = new Properties()
if (file(signPropsFilePath).exists()) {
    try(InputStream inputStream = new FileInputStream(signPropsFilePath)) {
        signProperties.load(inputStream)
    }
    String keyRingFilePath = getAbsolutePath(signProperties.getProperty(JarSign.PROPERTY_KEY_SECRET_KEY_RING_FILE, ''))
    signProperties.setProperty(JarSign.PROPERTY_KEY_SECRET_KEY_RING_FILE, keyRingFilePath);
}




repositories {
    mavenCentral()
}


test.onlyIf { !project.hasProperty("skipTests") }



dependencies {

    compileOnly fileTree(dir: '../LogExpressCore/build/libs/', include: ['*.jar'])

    implementation group: 'org.slf4j', name: 'slf4j-api', version: '1.7.36'
    testImplementation group: 'junit', name: 'junit', version: '4.+'
    testImplementation fileTree(dir: '../LogExpressCore/build/libs/', include: ['*.jar'])
}




javadoc {
    source = sourceSets.main.allJava
    def includes = ['com/hancomins/logexpress/slf4j/LogExpressLoggerFactory.java']



    include includes

    destinationDir = file("$buildDir/docs/javadoc")

    // 문서 생성 시 사용될 옵션 (선택 사항)
    options {
        encoding 'UTF-8'
        charSet 'UTF-8'
        author true
        version true
    }
}



jar {
    group = 'build'
    archiveBaseName.set("LogExpressSLF4J")

    manifest {
        attributes(
                'Implementation-Title': 'LogExpress Slf4j',       // 프로젝트 제목
                'Implementation-Version': project.version,          // 프로젝트 버전
                'Implementation-Vendor': 'HANCOM INNOSTREAM',      // 제작자 또는 회사 이름
                'Built-By': 'Sungbeom HONG', // 빌드한 사람
                'Build-Jdk': "${JAVA_VERSION}", // JDK 버전
                'Created-By': "Gradle ${gradle.gradleVersion}"  // Gradle 버전
        )
    }

    from('LICENSE') {
        into('/')
    }

    doLast {
        def jarFilePath = archiveFile.get().asFile.path
        JarSign.sign(jarFilePath, signProperties);
    }
}


task jarJavadoc(type: Jar, dependsOn: javadoc) {
    group = 'build'
    archiveBaseName.set("LogExpressSLF4J")
    classifier = 'javadoc'
    from javadoc.destinationDir
    archiveClassifier.set('javadoc') // Gradle 6.4 이상에서는 이 방법을 사용


    manifest {
        attributes(
                'Implementation-Title': ':LogExpress SLF4J',       // 프로젝트 제목
                'Implementation-Version': project.version,          // 프로젝트 버전
                'Implementation-Vendor': 'HANCOM INNOSTREAM',      // 제작자 또는 회사 이름
                'Built-By': 'Sungbeom HONG', // 빌드한 사람
                'Created-By': "Gradle ${gradle.gradleVersion}"  // Gradle 버전
        )
    }

    from('LICENSE') {
        into('/')
    }

    doLast {
        def jarFilePath = archiveFile.get().asFile.path
        JarSign.sign(jarFilePath, signProperties);
    }
}

task jarSources(type: Jar) {
    group = 'build'
    archiveBaseName.set("LogExpressSLF4J")
    classifier = 'sources'
    from sourceSets.main.allSource
    archiveClassifier.set('sources') // Gradle 6.4 이상에서는 이 방법을 사용


    manifest {
        attributes(
                'Implementation-Title': ':LogExpress SLF4J',       // 프로젝트 제목
                'Implementation-Version': project.version,          // 프로젝트 버전
                'Implementation-Vendor': 'HANCOM INNOSTREAM',      // 제작자 또는 회사 이름
                'Built-By': 'Sungbeom HONG', // 빌드한 사람
                'Build-Jdk': "${JAVA_VERSION}", // JDK 버전
                'Created-By': "Gradle ${gradle.gradleVersion}"  // Gradle 버전
        )
    }

    from('LICENSE') {
        into('/')
    }

    doLast {
        def jarFilePath = archiveFile.get().asFile.path
        JarSign.sign(jarFilePath, signProperties);
    }
}

task makePom {
    group = 'build'
    doLast {
        def pomFilePath = "${buildDir}/libs/LogExpressSLF4J-${version}.pom"

        PomBuilder.builder()
        PomBuilder.Developer developer = PomBuilder.newDeveloper("Sungbeom Hong")
                .setEmail("ice3x2@gmail.com")
                .setOrganization("HANCOM INNOSTREAM")
                .setOrganizationUrl("https://github.com/hancomins").setId("ice3x2");

        PomBuilder.SCM scm = PomBuilder.newSCM("hancomins/logexpress");

        PomBuilder.builder().setGroupId("io.github.hancomins")
                .setArtifactId("LogExpressSLF4J")
                .setVersion("${version}")
                .setName("LogExpressSLF4J")
                .setUrl("https://github.com/hancomins/logexpress")
                .addDeveloper(developer)
                .setScm(scm)
                .writeFile(pomFilePath);

        JarSign.sign(pomFilePath, signProperties);
    }
}


distTar.mustRunAfter(clean)
build.dependsOn(clean)
build.dependsOn(jarJavadoc)
build.dependsOn(jarSources)




task dist() {
    group = 'distribution'
    dependsOn build
    dependsOn makePom
    doLast {
        def sourceDir = new File("${buildDir}/libs")
        def targetDir = new File("${buildDir}/dist/io/github/hancomins/LogExpressSLF4J/${version}")
        def zipFile = new File("${buildDir}/dist/LogExpressSLF4J-${version}.zip")

        // 1. 대상 디렉토리 생성
        if (!targetDir.exists()) {
            targetDir.mkdirs()
        }

        // 2. 파일 복사
        sourceDir.eachFile { file ->
            def destFile = new File(targetDir, file.name)
            file.withInputStream { is ->
                destFile.withOutputStream { os ->
                    os << is
                }
            }
        }

        // 3. 파일 압축
        zipFile.withOutputStream { fos ->
            new java.util.zip.ZipOutputStream(fos).withCloseable { zos ->
                targetDir.eachFileRecurse { file ->
                    if (file.isFile()) {
                        def relativePath = file.path.replace(targetDir.path + File.separator, "")
                        def entryName = "io/github/hancomins/LogExpressSLF4J/${version}/" + relativePath
                        zos.putNextEntry(new java.util.zip.ZipEntry(entryName))
                        file.withInputStream { fis ->
                            zos << fis
                        }
                        zos.closeEntry()
                    }
                }
            }
        }

        println "Files from ${sourceDir} copied to ${targetDir} and zipped into ${zipFile}"
    }
}



String getAbsolutePath(String path) {
    if (path.startsWith("/") || path.matches("^[a-zA-Z]:.*")) {
        return file(path).getCanonicalFile().getAbsolutePath();
    } else {
        return file("${rootDir}/${path}").getCanonicalFile().getAbsolutePath();
    }
}